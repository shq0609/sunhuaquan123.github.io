<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>mysql必知必会 | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="查检索单个列 1SELECT prod_name FROM Products; 检索多个列 12SELECT prod_id, prod_name, prod_priceFROM Products; 检索所有列 1SELECT * FROM Products; DISTICT后所有列检索不同值 12SELECT DISTINCT vend_idFROM Products; 限制结果(mysql)">
<meta property="og:type" content="article">
<meta property="og:title" content="mysql必知必会">
<meta property="og:url" content="http://example.com/2020/12/06/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/index.html">
<meta property="og:site_name">
<meta property="og:description" content="查检索单个列 1SELECT prod_name FROM Products; 检索多个列 12SELECT prod_id, prod_name, prod_priceFROM Products; 检索所有列 1SELECT * FROM Products; DISTICT后所有列检索不同值 12SELECT DISTINCT vend_idFROM Products; 限制结果(mysql)">
<meta property="og:locale">
<meta property="article:published_time" content="2020-12-06T07:31:08.000Z">
<meta property="article:modified_time" content="2020-12-12T05:49:49.124Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-mysql必知必会" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/06/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" class="article-date">
  <time datetime="2020-12-06T07:31:08.000Z" itemprop="datePublished">2020-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      mysql必知必会
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>检索单个列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name FROM Products;</span><br></pre></td></tr></table></figure>
<p>检索多个列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name, prod_price</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<p>检索所有列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Products;</span><br></pre></td></tr></table></figure>
<p>DISTICT后所有列检索不同值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT vend_id</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<p>限制结果(mysql)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure>
<p>第5行开始检索5行，表有0行，limt 1,1 其实就是第2行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">LIMIT 5 OFFSET 5; ---可简化为LIMIT 5,5</span><br></pre></td></tr></table></figure>
<h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_price &#x3D; 3.49;</span><br></pre></td></tr></table></figure>
<p>ORDER BY位于必须WHERE之后</p>
<h4 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h4><p>NULL值（no value）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_price IS NULL; -- NULL区别0，空字符串或者空格，不能用&#39;&#x3D;&#39;。</span><br></pre></td></tr></table></figure>
<h4 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h4><p>操作符（operator）：AND，OR<br>求值顺序<br>优先级：（）&gt;AND&gt;OR 原则上最好都加括号，避免歧义。</p>
<h4 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h4><p>IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配，性能优于OR。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id IN ( &#39;DLL01&#39;, &#39;BRS01&#39; ) --可用WHERE vend_id &#x3D; &#39;DLL01&#39; OR vend_id &#x3D; &#39;BRS01&#39;替换</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<h4 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h4><p>WHERE⼦句中用来否定其后条件的关键字,复杂句用NOT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">WHERE NOT vend_id &#x3D; &#39;DLL01&#39;--WHERE vend_id &lt;&gt; &#39;DLL01&#39;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<h3 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h3><h3 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h3><p>LIKE指示DBMS，后跟的搜索模式利用通配符，LIKE是谓词（predicate）而不是操作符。<br>匹配通配符搜索只能用于文本字段（串），非文本数据类型字段不能使用通配符搜索。<br>通配符（wildcard）<br>用来匹配值的一部分的特殊字符<br>搜索模式（search pattern）<br>由字面值、通配符或两者组合构成的搜索条件</p>
<h3 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（%）通配符"></a>百分号（%）通配符</h3><p>%表示任何字符出现任意次数<br><code>WHERE prod_name LIKE &#39;Fish%&#39;;</code>–区分大小写 区别fish%<br>%表示0个或多个字符，’Fis%h’,’%ish%’。<br>“Fi空格 sh 空格 空格”，要匹配Fish字段就需要 ‘Fi%h%’或者函数去空格。<br>子句WHERE prod_name LIKE ‘%’不会匹配产品名称为NULL的行。</p>
<h3 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h3><p>匹配单个字符</p>
<h3 id="方括号（-）通配符"><a href="#方括号（-）通配符" class="headerlink" title="方括号（[ ]）通配符"></a>方括号（[ ]）通配符</h3><p>方括号（[]）通配符用来指定指定位置的一个字符。<br>WHERE cust_contact LIKE ‘[JM]%’<br>前缀字符^（脱字号）来否定<br>WHERE cust_contact LIKE ‘[^JM]%’ –WHERE NOT cust_contact LIKE ‘[JM]%’</p>
<h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p>mysql必须使用函数</p>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>别名（alias）是一个字段或值的替换名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(vend_name, &#39; (&#39;, vend_country, &#39;)&#39;)</span><br><span class="line">AS vend_title</span><br><span class="line">FROM Vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<p>expanded_price列输出quantity*item_price的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,</span><br><span class="line">quantity,</span><br><span class="line">item_price,</span><br><span class="line">quantity*item_price AS expanded_price</span><br><span class="line">FROM OrderItems</span><br><span class="line">WHERE order_num &#x3D; 20008;</span><br></pre></td></tr></table></figure>
<p>SELECT语句为测试、检验函数和计算提供了很好的用法。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>RTRIM()去掉字符串尾的空格的。不同DBMS使用函数不同。</p>
<h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><p>聚集函数（aggregate function） 对某些行运行的函数，计算并返回一个值.<br>AVG() 返回某列的平均值<br>COUNT() 返回某列的行数<br>MAX() 返回某列的最大值<br>MIN() 返回某列的最小值<br>SUM() 返回某列值之和<br>使用对所有行执行计算，指定ALL参数或不指定参数（默认是ALL）。<br>只包含不同的值，指定DISTINCT参数，DISTINCT不能用于COUNT(*)必须指定列。</p>
<p>AVG() 返回某列的平均值，只用于单个列，多个列用过个函数，忽略包含NULL值的行。<br><code>SELECT AVG(prod_price) AS avg_price FROM Products;</code><br>COUNT()函数有两种使用方式：<br>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。<br>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</p>
<p>MAX()返回指定列中的最大值，忽略NULL行。 汉字根据字符集大小决定，如utf-8齐大于刘，王。<br>MIN()的功能正好与MAX()功能相反<br>SUM()函数用来返回指定列值的和（总计），忽略NULL行<br>SELECT SUM(quantity) AS items_ordered<br>SELECT SUM(item_price*quantity) AS total_price </p>
<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM Products</span><br><span class="line">GROUP BY vend_id;--GROUP BY语句指示DBMS按vend_id排序并分组数据。</span><br></pre></td></tr></table></figure>

<p>使用GROUP BY语句重要的规定<br>GROUP BY子句可以包含任意数目的列，并对分组进行嵌套，进一步进行分组<br>嵌套分组数据将在最后指定的分组上嵌套<br>GROUP BY子句列出的不许是检索列或者表达式（不能是聚集函数）,GROUP BY子句中表达式与SELECT相同，不能用别名。<br>一般不允许GROUP BY拥有长度可变的数据类型<br>除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出。<br>NULL值作为一个分组返回<br>GROUP BY位于WHERE之后，ORDER BY之前。</p>
<p>通过相对位置指定列<br>GROUP BY 2, 1可表示按选择的第2个列分组，然后再按第1个列分组。</p>
<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>HAVING支持所有WHERE操作符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, COUNT(*) AS orders</span><br><span class="line">FROM Orders</span><br><span class="line">GROUP BY cust_id</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 2;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_price &gt;&#x3D; 4 --价格大于4</span><br><span class="line">GROUP BY vend_id</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 2;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_num, COUNT(*) AS items</span><br><span class="line">FROM OrderItems</span><br><span class="line">GROUP BY order_num</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 3</span><br><span class="line">ORDER BY items, order_num; --一般在使用GROUP BY子句时，应该也给出ORDER BY子句，保证数据正确排序。</span><br></pre></td></tr></table></figure>

<h3 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h3><p>SELECT     要返回的列或表达式  必须使用<br>FROM       从中检索数据的表    仅在从表选择数据时使用<br>WHERE      行级过滤           非必须使用<br>GROUP BY   分组说明           仅在按组计算聚集时使用<br>HAVING     组级过滤           非必须使用<br>ORDER BY   输出排序顺序       非必须使用</p>
<h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><p>子查询即嵌套在其他查询中的查询。SELECT是简单查询， 从单个数据库表中检索数据的单条语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM Orders</span><br><span class="line">WHERE order_num IN (SELECT order_num</span><br><span class="line">FROM OrderItems                      --可多层嵌套，实际考虑性能。</span><br><span class="line">WHERE prod_id &#x3D; &#39;RGAN01&#39;);</span><br></pre></td></tr></table></figure>
<p>上述分为两个步骤：<br>SELECT order_num FROM orderitems WHERE prod_id=’RGAN01’<br>SELECT cust_id FROM orders WHERE order_num IN (20007,20008)</p>
<p>作为子查询的SELECT语句只能查询单个列作为子查询的SELECT语句只能查询单个列。</p>
<h2 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h2><p>显示Customers表中每个顾客的订单总数，订单与相应的顾客ID存储在Orders表中。</p>
<ol>
<li>从Customers表中检索顾客列表；</li>
<li>对于检索出的每个顾客，统计其在Orders表中的订单数量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name,</span><br><span class="line">cust_state,</span><br><span class="line">(SELECT COUNT(*)</span><br><span class="line">FROM Orders</span><br><span class="line">WHERE Orders.cust_id &#x3D; Customers.cust_id) AS orders</span><br><span class="line">FROM Customers</span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure>
完全限定列名 表名.列名 </li>
</ol>
<h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><p>联结 执行中联结（join）表</p>
<h3 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h3><p>关系数据库就是要把信息分解成多个表，一类数据一个表，各表通过某些共同的值作为主键（primary key）互相关联。<br>关系数据库的可伸缩性远远比关系数据库要好，可伸缩性指的是能够适应不断增加的工作量而不失败。</p>
<p>用一条SELECT语句就检索出存储在多个表的数据。 </p>
<h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>等值联结（equijoin）也叫内联结（inner join）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM Vendors, Products</span><br><span class="line">WHERE Vendors.vend_id &#x3D; Products.vend_id;--使用WHERE语句进行联结。</span><br></pre></td></tr></table></figure>
<p>没有WHERE子句，第一个表中的每一行将与第二个表中的每一行配对。<br>笛卡儿积（cartesian product）由没有联结条件的表关系返回的结果,有时也叫叉联结（cross join），检索出的行的数<br>目将是第一个表中的行数乘以第二个表中的行数。</p>
<h3 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h3><p>内联结出了用WHERE以外，ANSI SQL规范首选INNER JOIN语法。参阅DBMS文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM Vendors INNER JOIN Products</span><br><span class="line">ON Vendors.vend_id &#x3D; Products.vend_id;--ON 替代WHERE</span><br></pre></td></tr></table></figure>
<h4 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h4><p>SELECT语句返回订购产品RGAN01的顾客列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM Customers, Orders, OrderItems</span><br><span class="line">WHERE Customers.cust_id &#x3D; Orders.cust_id</span><br><span class="line">AND OrderItems.order_num &#x3D; Orders.order_num</span><br><span class="line">AND prod_id &#x3D; &#39;RGAN01&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">FROM Orders</span><br><span class="line">WHERE order_num IN (SELECT order_num--用嵌套实现</span><br><span class="line">FROM OrderItems</span><br><span class="line">WHERE prod_id &#x3D; &#39;RGAN01&#39;));</span><br></pre></td></tr></table></figure>
<h3 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h3><h4 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h4><p>缩短SQL语句；<br>允许在一条SELECT语句中多次使用相同的表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM Customers AS C, Orders AS O, OrderItems AS OI</span><br><span class="line">WHERE C.cust_id &#x3D; O.cust_id</span><br><span class="line">AND OI.order_num &#x3D; O.order_num</span><br><span class="line">AND prod_id &#x3D; &#39;RGAN01&#39;;</span><br></pre></td></tr></table></figure>
<p>表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户端</p>
<p>内联结，自联结（self-join）、自然联结（natural join）和外<br>联结（outer join）</p>
<h4 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h4><p>给与Jim Jones同一公司的所有顾客发送一封信件<br>首先找出Jim Jones工作的公司，然后找出在该公司用作的顾客</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#方法一</span><br><span class="line">SELECT cust_id, cust_name, cust_contact</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_name &#x3D; (SELECT cust_name</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_contact &#x3D; &#39;Jim Jones&#39;);</span><br><span class="line">#方法二 自联结一般比子查询快</span><br><span class="line">SELECT c1.cust_id, c1.cust_name, c1.cust_contact</span><br><span class="line">FROM Customers AS c1, Customers AS c2</span><br><span class="line">WHERE c1.cust_name &#x3D; c2.cust_name</span><br><span class="line">AND c2.cust_contact &#x3D; &#39;Jim Jones&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="外联结"><a href="#外联结" class="headerlink" title="外联结"></a>外联结</h4><p>二种基本的外联结形式：左外联结和右外联结，–全外联结（full outer join）mysql不支持。<br>外联结：包含了那些在相关表中没有关联行的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Customers.cust_id, Orders.order_num</span><br><span class="line">FROM Customers LEFT OUTER JOIN Orders --OUTER JOIN来指定联结类型</span><br><span class="line">ON Customers.cust_id &#x3D; Orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表。</p>
<h3 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h3><p>检索所有顾客及每个顾客所下的订单数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#内联结</span><br><span class="line">SELECT Customers.cust_id,</span><br><span class="line">COUNT(Orders.order_num) AS num_ord</span><br><span class="line">FROM Customers INNER JOIN Orders</span><br><span class="line">ON Customers.cust_id &#x3D; Orders.cust_id</span><br><span class="line">GROUP BY Customers.cust_id;</span><br><span class="line"></span><br><span class="line">#外联结 外联结可以打印出所有客户，包括没订单的</span><br><span class="line">SELECT Customers.cust_id,</span><br><span class="line">COUNT(Orders.order_num) AS num_ord</span><br><span class="line">FROM Customers LEFT OUTER JOIN Orders</span><br><span class="line">ON Customers.cust_id &#x3D; Orders.cust_id</span><br><span class="line">GROUP BY Customers.cust_id;</span><br></pre></td></tr></table></figure>
<h3 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h3><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>利用UNION操作符将多条SELECT语句组合成一个结果集<br>并（union）或复合查询（compound query）<br>1.在一个查询中从不同的表返回结构数据；<br>2.对一个表执行多个查询，按一个查询返回数据。<br>需要Illinois、Indiana和Michigan等美国各个州的所有顾客的报表，还想包括不管位于哪个州的所有的Fun4All</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_state IN (&#39;IL&#39;,&#39;IN&#39;,&#39;MI&#39;)</span><br><span class="line">UNION</span><br><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_name &#x3D; &#39;Fun4All&#39;;</span><br><span class="line">#</span><br><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_state IN (&#39;IL&#39;,&#39;IN&#39;,&#39;MI&#39;)</span><br><span class="line">OR cust_name &#x3D; &#39;Fun4All&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h3><p>1.UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔。<br>2.UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。<br>3.列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。</p>
<h4 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h4><p>UNION总是完成与多个WHERE条件相同的操作，如果需要每个匹配行都出现，必须使用UNION ALL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_state IN (&#39;IL&#39;,&#39;IN&#39;,&#39;MI&#39;)</span><br><span class="line">UNION ALL  --UNION ALL返回所有值，UNION返回不重复的值</span><br><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_name &#x3D; &#39;Fun4All&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h4><p>用UNION组合查询时，只能使用一条ORDER BY子句，它必须位于最后一条SELECT语句之后.<br>另外两种UNION：EXCEPT（有时称为MINUS）可用来检索只在第一个表中存在而在第二个表中不存在的行；<br>INTERSECT可用来检索两个表中都存在的行。<br>UNION与别名组合，检索一个结果集，操作多个表。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>INSERT用来将行插入（或添加）到数据库表。<br>插入完整的行；<br>插入行的一部分；<br>插入某些查询的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO Customers-- INTO 可选</span><br><span class="line">VALUES(&#39;1000000006&#39;,&#39;Toy Land&#39;,&#39;123 Any Street&#39;,</span><br><span class="line">&#39;New York&#39;,&#39;NY&#39;,&#39;11111&#39;,&#39;USA&#39;,NULL,NULL);</span><br><span class="line">#推荐明确给出列名，这种方法还可以省略列。</span><br><span class="line">INSERT INTO Customers(cust_id,</span><br><span class="line">cust_name,cust_address,cust_city,cust_state,cust_zip,</span><br><span class="line">cust_country,cust_contact,cust_email)</span><br><span class="line">VALUES(&#39;1000000006&#39;,&#39;Toy Land&#39;,&#39;123 Any Street&#39;,&#39;New York&#39;,</span><br><span class="line">&#39;NY&#39;,&#39;11111&#39;,&#39;USA&#39;,NULL,NULL);</span><br></pre></td></tr></table></figure>
<p>省略的列必须满足以下某个条件。<br>该列定义为允许NULL值（无值或空值）。<br>在表定义中给出默认值。这表⽰如果不给出值，将使用默认值。</p>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><p>从名为CustNew的表中读出数据并插入到Customers表<br>在填充CustNew时，不应该使用已经在Customers中用过的cust_id值（如果主键值重复，后续的INSERT操作将会失败）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSERT INTO Customers(cust_id,</span><br><span class="line">cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,</span><br><span class="line">cust_zip,cust_country)</span><br><span class="line">SELECT cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,</span><br><span class="line">cust_state,cust_zip,cust_country FROM CustNew;</span><br></pre></td></tr></table></figure>
<p>INSERT SELECT中SELECT语句可以包含WHERE子句，以过滤插图的数据。<br>INSERT通常只插入一条，INSERT SELECT是个例外，它可以用一条INSERT插入多行。</p>
<h3 id="从一个表复制到另一个表"><a href="#从一个表复制到另一个表" class="headerlink" title="从一个表复制到另一个表"></a>从一个表复制到另一个表</h3><p>SELECT INTO将数据复制到一个新表<br>INSERT SELECT与SELECT INTO区别：前者导出数据，而后者导入数据.<br>创建一个名为CustCopy的新表，并把Customers表的整个内容复制到新表中。<br><code>SELECT * INTO CustCopy FROM Customers;</code><br><code>CREATE TABLE CustCopy AS SELECT * FROM Customers;</code></p>
<p>任何SELECT选项和子句都可以使用，包括WHERE和GROUP BY；<br>可利用联结从多个表插入数据；<br>不管从多少个表中检索数据，数据都只能插入到一个表中。</p>
<h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>有两种使用UPDATE的方式：更新表中的特定行；更新表中的所有行。<br>基本的UPDATE语句<br>要更新的表；列名和它们的新值；确定要更新哪些行的过滤条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE Customers</span><br><span class="line">SET cust_contact &#x3D; &#39;Sam Roberts&#39;,</span><br><span class="line">cust_email &#x3D; &#39;sam@toyland.com&#39;</span><br><span class="line">WHERE cust_id &#x3D; &#39;1000000006&#39;; --没有这句，DBMS将用这个电子邮件地址更新Customers表中的所有行</span><br></pre></td></tr></table></figure>
<p>UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据</p>
<p>要删除某个列的值，可设置它为NULL（假如表定义允许NULL值），区别’’，后者是个值。<br>UPDATE Customers<br>SET cust_email = NULL<br>WHERE cust_id = ‘1000000005’;</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>有两种使用DELETE的方式：<br>从表中删除特定的行；<br>从表中删除所有行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM Customers</span><br><span class="line">WHERE cust_id &#x3D; &#39;1000000006&#39;;</span><br></pre></td></tr></table></figure>

<p>DELETE不需要列名或通配符。DELETE删除整行而不是删除列。要删除指定的列，请使用UPDATE语句。<br>DELETE删除表的内容而不是表。<br>TRUNCATE TABLE语句不记录数据变动，删除所有行更快。</p>
<h3 id="更新和删除的指导原则"><a href="#更新和删除的指导原则" class="headerlink" title="更新和删除的指导原则"></a>更新和删除的指导原则</h3><ol>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。</li>
<li>保证每个表都有主键，尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。</li>
<li>在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进⾏测试，保证它过滤的是正确的记录，<br>以防编写的WHERE⼦句不正确。</li>
<li>使用强制实施引用完整性的数据库，这样DBMS将不允许删除其数据与其他表相关联的行。</li>
<li>有的DBMS允许数据库管理员施加约束，防止执行不带WHERE子句的UPDATE或DELETE语句。如果所采用的DBMS支持这个特性，应该使用它。<h2 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3>CREATE TABLE创建表<br>新表的名字，在关键字CREATE TABLE之后给出；<br>表列的名字和定义，用逗号分隔；<br>有的DBMS还要求指定表的位置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Products</span><br><span class="line">(</span><br><span class="line">prod_id CHAR(10) NOT NULL, --NOT NULL 插入没有值的列时会报错。</span><br><span class="line">vend_id CHAR(10) NOT NULL,</span><br><span class="line">prod_name CHAR(254) NOT NULL,</span><br><span class="line">prod_price DECIMAL(8,2) NOT NULL,</span><br><span class="line">prod_desc VARCHAR(1000) --不指定NULL，默认为NULL。</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
只有不允许NULL值的列可作为主键，允许NULL值的列不能作为唯一标识<br>默认值在CREATE TABLE语句的列定义中用关键字DEFAULT指定<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE OrderItems</span><br><span class="line">(</span><br><span class="line">order_num INTEGER NOT NULL,</span><br><span class="line">order_item INTEGER NOT NULL,</span><br><span class="line">prod_id CHAR(10) NOT NULL,</span><br><span class="line">quantity INTEGER NOT NULL DEFAULT 1,</span><br><span class="line">item_price DECIMAL(8,2) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
MySQL用户指定DEFAULT CURRENT_DATE()；<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3>理想情况下，不要在表中包含数据时对其进行更新。应该在表的设计过程中充分考虑未来可能的需求，避免今后对表的结构做大改动。<br>所有的DBMS都允许给现有的表增加列，不过对所增加列的数据类型（以及NULL和DEFAULT的使用）有所限制。<br>许多DBMS不允许删除或更改表中的列。<br>多数DBMS允许重新命名表中的列。<br>许多DBMS限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。<br>使用ALTER TABLE更改表结构</li>
<li>在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）；</li>
<li>列出要做哪些更改。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Vendors ADD vend_phone CHAR(20);</span><br><span class="line">ALTER TABLE Vendors DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure>
使用ALTER TABLE要极为⼩⼼，应该在进行改动前做完整的备份（模式和数据的备份）<br>数据库表的更改不能撤销，如果增加了不需要的列，也许无法删除它们</li>
</ol>
<p>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：</p>
<ol>
<li>用新的列布局创建一个新表；</li>
<li>使用INSERT SELECT语句（关于这条语句的详细介绍，请参阅<br>第15课）从旧表复制数据到新表。有必要的话，可以使用转换函数和计算字段；</li>
<li>检验包含所需数据的新表；</li>
<li>重命名旧表（如果确定，可以删除它）；</li>
<li>用旧表原来的名字重命名新表；</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键。</li>
</ol>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>DROP TABLE语句<br>DROP TABLE CustCopy; –删除表没有确认，也不能撤销，执行这条语句将永久删除该表</p>
<h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><p>MySQL使用RENAME</p>
<h2 id="视图（虚拟的表）"><a href="#视图（虚拟的表）" class="headerlink" title="视图（虚拟的表）"></a>视图（虚拟的表）</h2><p>CREATE VIEW只能用于创建不存在的视图<br>DROP VIEW viewname;</p>
<p>利用视图简化复杂的联结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW ProductCustomers AS</span><br><span class="line">SELECT cust_name, cust_contact, prod_id</span><br><span class="line">FROM Customers, Orders, OrderItems</span><br><span class="line">WHERE Customers.cust_id &#x3D; Orders.cust_id</span><br><span class="line">AND OrderItems.order_num &#x3D; Orders.order_num;</span><br><span class="line"></span><br><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM ProductCustomers</span><br><span class="line">WHERE prod_id &#x3D; &#39;RGAN01&#39;;</span><br><span class="line">#用视图重新格式化检索出的数据</span><br><span class="line"></span><br><span class="line">CREATE VIEW VendorLocations AS</span><br><span class="line">SELECT RTRIM(vend_name) + &#39; (&#39; + RTRIM(vend_country) + &#39;)&#39;--mysql拼接必须使用函数</span><br><span class="line">AS vend_title</span><br><span class="line">FROM Vendors;</span><br><span class="line">SELECT * FROM VendorLocations;</span><br><span class="line"></span><br><span class="line">#用视图过滤不想要的数据</span><br><span class="line">CREATE VIEW CustomerEMailList AS</span><br><span class="line">SELECT cust_id, cust_name, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_email IS NOT NULL; --过滤没有邮件的客户</span><br><span class="line"></span><br><span class="line">SELECT * FROM CustomerEMailList;</span><br><span class="line">#使用视图与计算字段</span><br><span class="line">CREATE VIEW OrderItemsExpanded AS</span><br><span class="line">SELECT order_num,</span><br><span class="line">prod_id,</span><br><span class="line">quantity,</span><br><span class="line">item_price,</span><br><span class="line">quantity*item_price AS expanded_price</span><br><span class="line">FROM OrderItems；</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM OrderItemsExpanded</span><br><span class="line">WHERE order_num &#x3D; 20008;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><p>使用事务处理（transaction processing），通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库的完整性。<br>事务处理需要知道的几个术语<br>事务（transaction）指一组SQL语句；<br>回退（rollback）指撤销指定SQL语句的过程；<br>提交（commit）指将未存储的SQL语句结果写⼊数据库表；<br>保留点（savepoint）指事务处理中设置的临时占位符<br>（placeholder），可以对它发布回退（与回退整个事务处理不同）。<br>事务处理用来管理INSERT、UPDATE和DELETE语句<br>不能回退SELECT语句，CREATE或DROP操作。事务处理中可以使用这些语句，但进行回退<br>时，这些操作也不撤销。</p>
<h3 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h3><p>一般的SQL语句都是针对数据库表直接执行和编写的。这就是所谓的<br>隐式提交（implicit commit），即提交（写或保存）操作是自动进行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#MySQL</span><br><span class="line">START TRANSACTION</span><br><span class="line">...</span><br><span class="line">DELETE FROM Orders;</span><br><span class="line">ROLLBACK;   --回退（撤销）</span><br><span class="line"></span><br><span class="line">SET TRANSACTION</span><br><span class="line">DELETE OrderItems WHERE order_num &#x3D; 12345;</span><br><span class="line">DELETE Orders WHERE order_num &#x3D; 12345;</span><br><span class="line">COMMIT;--mysql一般默认开启aotucommit，使用show variables like &#39;%autocommit%&#39;查看</span><br><span class="line">#保留点</span><br><span class="line">SAVEPOINT delete1;-- 支持回退部分事务，回退到占位符即保留点。</span><br></pre></td></tr></table></figure>
<h3 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h3><h3 id="高级SQL特性"><a href="#高级SQL特性" class="headerlink" title="高级SQL特性"></a>高级SQL特性</h3><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>外键有助防止意外删除<br>级联删除（cascading delete）：从一个表中删除行时删除所有相关的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#使用了REFERENCES关键字，它表示cust_id中的任何值都必须是Customers表的cust_id中的值。</span><br><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">order_num INTEGER NOT NULL PRIMARY KEY,</span><br><span class="line">order_date DATETIME NOT NULL,</span><br><span class="line">cust_id CHAR(10) NOT NULL REFERENCES</span><br><span class="line">Customers(cust_id)</span><br><span class="line">);</span><br><span class="line">#在ALTER TABLE语句中用CONSTRAINT语法来完成</span><br><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD CONSTRAINT</span><br><span class="line">FOREIGN KEY (cust_id) REFERENCES Customers (cust_id)</span><br></pre></td></tr></table></figure>
<p>唯一约束既可以用UNIQUE关键字在表定义中定义，也可以用单独的CONSTRAINT定义。<br>与主键的区别：<br>表可包含多个唯一约束，但每个表只允许一个主键。<br>唯一约束列可包含NULL值。<br>唯一约束列可修改或更新。<br>唯一约束列的值可重复使用。<br>与主键不一样，唯一约束不能用来定义外键。</p>
<h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。</p>
<p>```<br>CREATE TABLE OrderItems<br>(<br>order_num INTEGER NOT NULL,<br>order_item INTEGER NOT NULL,<br>prod_id CHAR(10) NOT NULL,<br>quantity INTEGER NOT NULL CHECK (quantity &gt; 0),<br>item_price MONEY NOT NULL<br>);</p>
<p>ADD CONSTRAINT CHECK (gender LIKE ‘[MF]’)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/06/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" data-id="ckipfqjc4000edobxcztc1bbn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/12/13/%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          博客常见问题
        
      </div>
    </a>
  
  
    <a href="/2020/12/06/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">linux基本操作</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/15/HCIA/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/12/14/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/">图床搭建</a>
          </li>
        
          <li>
            <a href="/2020/12/14/MarkDown%E8%AF%AD%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/12/13/%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">博客常见问题</a>
          </li>
        
          <li>
            <a href="/2020/12/06/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">mysql必知必会</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>