<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title></title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name">
<meta property="og:locale">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-HCIA" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/15/HCIA/" class="article-date">
  <time datetime="2020-12-15T03:37:01.353Z" itemprop="datePublished">2020-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HCIA基础知识"><a href="#HCIA基础知识" class="headerlink" title="HCIA基础知识"></a>HCIA基础知识</h1><h2 id="数据链路层-物理层"><a href="#数据链路层-物理层" class="headerlink" title="数据链路层+物理层"></a>数据链路层+物理层</h2><p>共享介质网络：不同主机同时发送数据导致信号冲突。<br>冲突域是同一共享介质网络节点集合，载波侦听多路访问/冲突检测技术 CSMA/CD  </p>
<p>工作过程：  </p>
<ol>
<li>终端设备检测共享线路状态。线路空闲则发，不空闲则延迟后发。（延迟发送根据退避算法决定）  </li>
<li>检测到冲突停止发送数据，发送阻塞信息，强化冲突信号，并延迟重发。  </li>
<li>先听后发，边发边听，冲突停发，随机延迟后重发。 </li>
</ol>
<p>双工模式:</p>
<ul>
<li><p>半双工：一发一收，需要CSMA/CD机制。  </p>
</li>
<li><p>全双工：同时收发，不需要CSMA/CD机制。  </p>
<h3 id="以太网帧结构"><a href="#以太网帧结构" class="headerlink" title="以太网帧结构"></a>以太网帧结构</h3><p>OSI 开放系统系统互联参考模型 (Open System Interconnection):</p>
</li>
<li><p>物理层：在设备间传输比特流，规定电平，电缆针脚等电气属性。      </p>
</li>
<li><p>数据链路层：比特组合成帧，链路层地址（MAC)寻址，差错检测。     </p>
</li>
<li><p>网络层：网络之间逻辑转发问题，IP寻址，路由选择。</p>
</li>
<li><p>传输层：保证端到端可靠传输，TCP/UDP数据传递，差错校验。   </p>
</li>
<li><p>会话层：建立管理维护会话连接。  </p>
</li>
<li><p>表示层：数据格式化，加密解密，压缩。  </p>
</li>
<li><p>应用层：为应用程序提供网络服务。  </p>
</li>
</ul>
<p>TCP/IP:</p>
<ul>
<li>应用层：PDU （Protocol Data Unit）协议数据单元  </li>
<li>传输层：TCP头+PDU=Segment 数据段  </li>
<li>网络层：IP头+TCP头+PDU=Packet 包  </li>
<li>网络接口层：1)数据链路层头+IP头+TCP头+PDU=Frame 数据帧 2)数据帧化为比特，通过网络介质传输.<h4 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h4></li>
</ul>
<p>以太网数据帧两种格式，选着哪种由网络层决定。<br>Length/type&gt;=1536（0x0600）Ethernet_II<br>Length/type&lt;=1500（0x05DC）IEEE802.3</p>
<h4 id="以太网MACA地址"><a href="#以太网MACA地址" class="headerlink" title="以太网MACA地址"></a>以太网MACA地址</h4><p>网络设备MAC地址全球唯一，前24位由IEEE统一分配，后24位为厂商自行分配。</p>
<p>局域网帧发送方式：</p>
<ul>
<li>单播：第8比特为0。单个主机收，其他主机丢弃。</li>
<li>广播：目的地址为FF:FF:FF:FF,所有主机收。</li>
<li>组播：第8比特为1，同组主机收，其他主机丢。</li>
</ul>
<p>数据帧接收：检查目的mac地址判断是否丢弃，接收后，进行帧校验（检查真校验序列FCS），通过校验，根据Type字段发给上层协议校验，0X0800为IP协议，0X0806为ARP协议。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP头部信息用来知道网络设备对报文进行路由和分片。<br>IPV4地址为32比特二进制，点分十进制表示，包括网络号和主机号。<br>两个特殊的IPV4地址：主机位全1表示广播地址，全0表示网段。</p>
<h4 id="有类IP编制"><a href="#有类IP编制" class="headerlink" title="有类IP编制"></a>有类IP编制</h4><p>IP地址分类:</p>
<ul>
<li>A类 ： 最高位固定为0    1.0.0.0-126.255.255.255   ，适用于大型网络  </li>
<li>B类 ： 最高位固定为10   128.0.0.0-191.255.255.255 ，适用于中型网络  </li>
<li>C类 ： 最高位固定为110  192.0.0.0-223.255.255.255 ，适用于小型网络  </li>
<li>D类 ： 最高位固定为1110 224.0.0.0-239.255.255.255 ，用于组播  </li>
<li>E类 ： 最高位固定为1111 240.192.0.0.0-255.255.255.255，用于科研保留  </li>
</ul>
<p>IP地址计算：<br>128.0,192.0.0没有被分配可以查看RFC3330，这两个地址暂时被保留，没有分配。<br>A类:可指派网络数：2^7-2,0.0.0.0表示任何网络;最大主机数2^24-2。<br>B类:可指派网络数：2^14-1，128.0保留;最大主机数2^16-2。<br>C类:可指派网络数：2^21-1,192.0.0保留;最大主机数2^8-2。</p>
<h4 id="无类IP编制"><a href="#无类IP编制" class="headerlink" title="无类IP编制"></a>无类IP编制</h4><p>可变长子网掩码(VLSM)<br>通过可变长子网掩码解决有类IP编制，浪费地址的缺陷。常规做法，借用主机位作为子网位。<br>无类域间路由（Classless Inter Domain Routing),RFC1817<br>将路由表中的若干条路由汇聚成一条，减少路由表规模，提高路由器可扩展性。<br>网关：接收并处理本地网络报文并转发到目的网段的设备。<br>网关地址：网关设备连接本地的接口地址。<br>IP包分片；TTL生存时间，防止堵塞；协议号，标识网络层协议。</p>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>消息控制协议ICMP（Internet Control Message Protocol）是网络层的重要协议，用来传递各种差错和控制信息，主要用于网络信息收集，故障诊断。</p>
<p>ICMP消息：</p>
<ul>
<li>ICMP Redirect重定向：用于支持路由功能，主机通过默认网关地址发送报文，默认网关检查目的地址，若不匹配。发送ICMP重定向消息给主机。主机向正确IP地址发送报文。</li>
<li>ICMP Echo消息：分为Request(Type为8)和Replay（Type为0），常用于诊断网络连通性。  </li>
<li>ICMP 错误消息：出现目的不可达或者无法访问等问题时，返回给发送主机。</li>
</ul>
<p>IP消息类型和编码类型imag<br>ICMP应用-Ping：Ping用于检测网络连通。<br>ICMP应用-Tarcet：Tracert用于检测路由环路，检测网络丢包和时延。<br>若IP报文到达目的地之前TTL已经为0，则目的设备丢弃该包，返回TTL超时的ICMP消息。</p>
<h3 id="ARP消息"><a href="#ARP消息" class="headerlink" title="ARP消息"></a>ARP消息</h3><p>ARP (Address Resolution Protocol)协议实现通过目的IP地址获取目的MAC地址。<br>ARP报文不能穿越路由器，不能转发到其他广播域。<br>网络设备通过ARP协议建立IP地址和MAC地址之间的映射。  </p>
<h4 id="ARP缓存表（ARP-Cache）"><a href="#ARP缓存表（ARP-Cache）" class="headerlink" title="ARP缓存表（ARP Cache）"></a>ARP缓存表（ARP Cache）</h4><p>网络设备发送数据前检查ARP缓存表，获取对端设备MAC地址并封装帧，然后转发。<br>若没有，通过APR Request报文来获取该地址并存入ARP缓存表。ARP缓存表表项是有时间的，过期删除表项。<br>若目标设备位于其他网络，则源设备获取网关MAC地址封装，然后由网关转发。</p>
<h4 id="ARP以及ARP代理过程"><a href="#ARP以及ARP代理过程" class="headerlink" title="ARP以及ARP代理过程"></a>ARP以及ARP代理过程</h4><p>ARP消息主要字段：目的IP地址，源IP地址，目的MAC地址，源MAC地址，操作类型。</p>
<p>ARP过程:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR </span><br><span class="line">A[Host A]-.- B[Host B] </span><br></pre></td></tr></table></figure>

<ol>
<li>A广播ARP Request报文，此时ARP报文目的MAC地址为0，以太网目的MAC为广播地址。</li>
<li>B收到ARP请求报文，检查报文目的IP地址与自身IP地址，若不匹配，则不响应；若匹配，记录ARP报文的源MAC地址和源IP信息到ARP缓存表中。</li>
<li>B单播发送ARP响应消息给A，源IP地址和源MAC地址为B地址，操作类型变为Reply。</li>
<li>A收到响应消息，检查ARP消息目的MAC地址与自己MAC地址是否匹配，匹配则记入ARP缓存。<br>ARP代理 ：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[Host A]-.-B[B1路由器B2]</span><br><span class="line">B[B1路由器B2]-.-C[Host C]</span><br></pre></td></tr></table></figure>
路由器开启ARP代理功能，收到A ARP请求，查找路由表，如果有主机C路由表项，使用B1接口的MAC地址来响应A，主机A，收到响应消息后，根据BA接口MAC地址进行数据转发。</li>
</ol>
<p>免费ARP可以用来探测IP地址冲突，具体操作为，将ARP请求消息目的IP设置为自己的IP，如果收到响应，就说明IP冲突了。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层定义了主机应用程序之间端到端的连通性，使用确认机制和滑动窗口机制来保证可靠性。</p>
<h3 id="传输控制协议-TCP（Transimisson-Control-Protocol"><a href="#传输控制协议-TCP（Transimisson-Control-Protocol" class="headerlink" title="传输控制协议 TCP（Transimisson Control Protocol)"></a>传输控制协议 TCP（Transimisson Control Protocol)</h3><h4 id="TCP端口号"><a href="#TCP端口号" class="headerlink" title="TCP端口号"></a>TCP端口号</h4><p>端口号用于区分不同网络服务，知名端口：1-1023，动态端口：1024-65535。</p>
<table>
<thead>
<tr>
<th>协议</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>FTP</td>
<td>21,20</td>
</tr>
<tr>
<td>HTTP</td>
<td>80,</td>
</tr>
<tr>
<td>Telnet</td>
<td>23</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
</tr>
</tbody></table>
<h4 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h4><p>TCP报文头简述：</p>
<ul>
<li>序列号：Seq序号，占32位，发起方发送数据时标记，随机生成。</li>
<li>确认号：ack序号，占32位，ACK标志位为1时有效，Ack=Seq+1，随机生成。</li>
<li>标志位：共6个，其中ACK为确认建立连接，SYN为请求建立连接，FIN为释放连接。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Note Over Client,Server:TCP三次握手</span><br><span class="line">Note Over Client:SYN_SENT</span><br><span class="line">Client-&gt;Server:SYN&#x3D;1,seq&#x3D;J</span><br><span class="line">Note over Server:SYN_RCVD</span><br><span class="line">Server-&gt;Client:SYN&#x3D;1,ACK&#x3D;1,ack&#x3D;J+1,seq&#x3D;K</span><br><span class="line">Note over Client:ESTABILSHED</span><br><span class="line">Client-&gt;Server:ACK&#x3D;1,ack&#x3D;K+1</span><br></pre></td></tr></table></figure>

<h4 id="TCP传输过程"><a href="#TCP传输过程" class="headerlink" title="TCP传输过程"></a>TCP传输过程</h4><p>目的设备收到源端设备数据段会返回确认报文，源端设备收到确认报文后，继续发送数据段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Note over Host A,Host B:TCP数据段传输</span><br><span class="line">Note left of Host A:数据段 N</span><br><span class="line">Host A--Host B:Seq&#x3D;M-M+499</span><br><span class="line">Note left of Host A:数据段 N+1</span><br><span class="line">Host A--Host B:Seq&#x3D;M+500-M+999</span><br><span class="line">Note left of Host A:数据段 N+2</span><br><span class="line">Host B-&gt;Host A:确认号：Ack&#x3D;M+1000</span><br><span class="line">Host A--Host B:Seq&#x3D;M+1000-M+1499</span><br><span class="line">Note left of Host A:数据段 N+3</span><br><span class="line">Host B-&gt;Host A:若接收失败，确认号Ack&#x3D;M+1000</span><br><span class="line">Host A--Host B:Seq&#x3D;M+1500-M+1999</span><br></pre></td></tr></table></figure>

<p>假设发送500字节大小数据段：seq：M=M-M+499，目的设备通过M=M+499+1来确认。若第3段数据传输失败，仍就用第2段数据的确认消息（Seq:M=1000）去确认。</p>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Note over Host A,Host B:TCP窗口滑动</span><br><span class="line">Host A--Host B:length 1024 windows 3072</span><br><span class="line">Host A--Host B:length 1024 windows 3072</span><br><span class="line">Host A--Host B:length 1024 windows 3072</span><br><span class="line">Note right of Host B:服务器收到2个数据缓存满了，\n第3个数据段被丢失。</span><br><span class="line">Host B-&gt;Host A:ack 2049 windows </span><br><span class="line">Host A--Host B:length 1024 windows 2048</span><br><span class="line">Host A--Host B:length 1024 windows 2048</span><br><span class="line">Host B-&gt;Host A:ack 5121 windows 2048</span><br><span class="line">Host A--Host B:length 1024 windows 2048</span><br><span class="line">Host A--Host B:length 1024 windows 2048</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="TCP四次握手"><a href="#TCP四次握手" class="headerlink" title="TCP四次握手"></a>TCP四次握手</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Note Over Client,Server:TCP四次握手</span><br><span class="line">Client-&gt;Server:FIN,ACK（seq&#x3D;a，ack&#x3D;b）</span><br><span class="line">Server-&gt;Client:ACK（seq&#x3D;b,ack&#x3D;a+1)</span><br><span class="line">Note left of Client:关闭</span><br><span class="line">Server-&gt;Client:FIN,ACK（seq&#x3D;b,ack&#x3D;a+1)</span><br><span class="line">Client-&gt;Server:ACK（seq&#x3D;a+1，ack&#x3D;b+1）</span><br><span class="line">Note right of Server:关闭</span><br></pre></td></tr></table></figure>



<h3 id="用户数据协议-UDP-User-Datagram-Protocol"><a href="#用户数据协议-UDP-User-Datagram-Protocol" class="headerlink" title="用户数据协议 UDP (User Datagram Protocol)"></a>用户数据协议 UDP (User Datagram Protocol)</h3><p>应用程序对可靠性要求不高，对传输速度和延迟要求较高。</p>
<h4 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h4><p>UDP报文分为UDP报文头和UDO数据区域两部分。UDP头共8字节，由源端口号，目的端口号，UDP长度，UDP校验和组成。UDP适合实时数据传输，如语音和视频通信，相比TCP传输效率更高，开销更小，无法保证数据可靠性。</p>
<h4 id="UDP传输过程"><a href="#UDP传输过程" class="headerlink" title="UDP传输过程"></a>UDP传输过程</h4><p>UDP需要应用程序提供报文到达确认，排序和流量控制,UDP不提供重传机制，重传会带来延迟和重复数据，降低用户体验。UDP使用传输对音频，视频敏感的流量。</p>
<p>数据转发过程分为本地转发和远端转发，原理一样。</p>
<ul>
<li><p>IP封装：注意源和目的IP地址，协议字段表示传输层协议，TCP0x60。</p>
</li>
<li><p>TCP封装：必须填充目的端口和源端口，初始序列号和确认序列号字段，标识位端口字段以及校验和字段。</p>
</li>
</ul>
<h2 id="数据转发过程概述"><a href="#数据转发过程概述" class="headerlink" title="数据转发过程概述"></a>数据转发过程概述</h2><p>环境如下：</p>
<p>imag</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">查找路由--&gt;查找mac地址--&gt;以太网封装--&gt;数据帧转发</span><br></pre></td></tr></table></figure>

<h4 id="查找路由（IP）"><a href="#查找路由（IP）" class="headerlink" title="查找路由（IP）"></a>查找路由（IP）</h4><p>主机都会独自维护各自的路由表项，发送数据前通过查找路由检查是否可以到达目的。默认都会维护一条默认路由（0.0.0.0），数据发送到默认网关。</p>
<h4 id="数据帧转发-ARP"><a href="#数据帧转发-ARP" class="headerlink" title="数据帧转发 ARP"></a>数据帧转发 ARP</h4><p>查找路由后，数据包封装成帧，主机通过查询ARP缓存表获取下一跳MAC地址，一般为网关MAC地址。如果没有获取到，主机会发送ARP请求消息获取网关MAC地址。</p>
<h3 id="以太网封装"><a href="#以太网封装" class="headerlink" title="以太网封装"></a>以太网封装</h3><p>主机在链路层封装数据帧，遵循IEEE802.3或者Ethernet_II标准。Ethernet_II类型字段填充0X0800表示使用IP协议。源MAC地址为主机MAC，目的MAC地址为网关接口MAC地址。</p>
<h3 id="数据帧转发过程"><a href="#数据帧转发过程" class="headerlink" title="数据帧转发过程"></a>数据帧转发过程</h3><ul>
<li>主机在半双工状态下，使用CSMA/CD来检测链路是否空闲。</li>
<li>前导码用于使接受者进入同步状态，定界符用于指示帧的开始。</li>
</ul>
<table>
<thead>
<tr>
<th>Preamble</th>
<th>SFD</th>
<th>Ethernet Header</th>
<th>IP Header</th>
<th>TCP Header</th>
<th>Data</th>
<th>FCS</th>
</tr>
</thead>
<tbody><tr>
<td>56bits 1010….</td>
<td>10101011</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
    <tr>
        <td><center>
        <img src="https://gitee.com/sunhuaquan123/pic-go/raw/master/hcia_%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91" />
        </center>
        <center>
        数据转发环境
        </center></td> 
    <tr>
</table>

<p>主机A访问服务器A的web服务，假定建立TCP之后的数据转发流程：</p>
<ol>
<li>主机A会对发送应用数据进行加密压缩等操作，之后进行传输层封装。</li>
<li>进行网络层数据封装，如果IP报文大于网络最大传输单元，进行分片。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/15/HCIA/" data-id="ckipfqjal0000dobx0rwfdvmh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-图床搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/14/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/" class="article-date">
  <time datetime="2020-12-14T13:36:13.000Z" itemprop="datePublished">2020-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/14/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/">图床搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/14/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/" data-id="ckipfqjbt000adobx5s6z6emn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MarkDown语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/14/MarkDown%E8%AF%AD%E6%B3%95/" class="article-date">
  <time datetime="2020-12-14T02:14:16.829Z" itemprop="datePublished">2020-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><p>graph LR</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/14/MarkDown%E8%AF%AD%E6%B3%95/" data-id="ckipfqjb20001dobx0s3pd40l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-博客常见问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/13/%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-12-13T13:06:37.000Z" itemprop="datePublished">2020-12-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/13/%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">博客常见问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>NODEJS变量问题：<br>gitbash输入hexo报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;c&#x2F;Users&#x2F;zhouy&#x2F;AppData&#x2F;Roaming&#x2F;npm&#x2F;hexo: line 12: node: command not found</span><br></pre></td></tr></table></figure>

<p>系统变量添加:变量名：NODE_PATH  变量值：C:\Program Files\nodejs    </p>
<p>用户变量path路径添加%NODE_PATH%</p>
<p><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/64d05a021974acde54f73b70.html">https://jingyan.baidu.com/article/64d05a021974acde54f73b70.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/13/%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" data-id="ckipfqjbr0009dobxg459gh5l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql必知必会" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/06/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" class="article-date">
  <time datetime="2020-12-06T07:31:08.000Z" itemprop="datePublished">2020-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/06/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">mysql必知必会</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>检索单个列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name FROM Products;</span><br></pre></td></tr></table></figure>
<p>检索多个列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id, prod_name, prod_price</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<p>检索所有列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM Products;</span><br></pre></td></tr></table></figure>
<p>DISTICT后所有列检索不同值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT vend_id</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<p>限制结果(mysql)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">LIMIT 5;</span><br></pre></td></tr></table></figure>
<p>第5行开始检索5行，表有0行，limt 1,1 其实就是第2行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">LIMIT 5 OFFSET 5; ---可简化为LIMIT 5,5</span><br></pre></td></tr></table></figure>
<h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_price &#x3D; 3.49;</span><br></pre></td></tr></table></figure>
<p>ORDER BY位于必须WHERE之后</p>
<h4 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h4><p>NULL值（no value）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_price IS NULL; -- NULL区别0，空字符串或者空格，不能用&#39;&#x3D;&#39;。</span><br></pre></td></tr></table></figure>
<h4 id="组合WHERE子句"><a href="#组合WHERE子句" class="headerlink" title="组合WHERE子句"></a>组合WHERE子句</h4><p>操作符（operator）：AND，OR<br>求值顺序<br>优先级：（）&gt;AND&gt;OR 原则上最好都加括号，避免歧义。</p>
<h4 id="IN操作符"><a href="#IN操作符" class="headerlink" title="IN操作符"></a>IN操作符</h4><p>IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配，性能优于OR。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id IN ( &#39;DLL01&#39;, &#39;BRS01&#39; ) --可用WHERE vend_id &#x3D; &#39;DLL01&#39; OR vend_id &#x3D; &#39;BRS01&#39;替换</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<h4 id="NOT操作符"><a href="#NOT操作符" class="headerlink" title="NOT操作符"></a>NOT操作符</h4><p>WHERE⼦句中用来否定其后条件的关键字,复杂句用NOT。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">WHERE NOT vend_id &#x3D; &#39;DLL01&#39;--WHERE vend_id &lt;&gt; &#39;DLL01&#39;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
<h3 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h3><h3 id="LIKE操作符"><a href="#LIKE操作符" class="headerlink" title="LIKE操作符"></a>LIKE操作符</h3><p>LIKE指示DBMS，后跟的搜索模式利用通配符，LIKE是谓词（predicate）而不是操作符。<br>匹配通配符搜索只能用于文本字段（串），非文本数据类型字段不能使用通配符搜索。<br>通配符（wildcard）<br>用来匹配值的一部分的特殊字符<br>搜索模式（search pattern）<br>由字面值、通配符或两者组合构成的搜索条件</p>
<h3 id="百分号（-）通配符"><a href="#百分号（-）通配符" class="headerlink" title="百分号（%）通配符"></a>百分号（%）通配符</h3><p>%表示任何字符出现任意次数<br><code>WHERE prod_name LIKE &#39;Fish%&#39;;</code>–区分大小写 区别fish%<br>%表示0个或多个字符，’Fis%h’,’%ish%’。<br>“Fi空格 sh 空格 空格”，要匹配Fish字段就需要 ‘Fi%h%’或者函数去空格。<br>子句WHERE prod_name LIKE ‘%’不会匹配产品名称为NULL的行。</p>
<h3 id="下划线（-）通配符"><a href="#下划线（-）通配符" class="headerlink" title="下划线（_）通配符"></a>下划线（_）通配符</h3><p>匹配单个字符</p>
<h3 id="方括号（-）通配符"><a href="#方括号（-）通配符" class="headerlink" title="方括号（[ ]）通配符"></a>方括号（[ ]）通配符</h3><p>方括号（[]）通配符用来指定指定位置的一个字符。<br>WHERE cust_contact LIKE ‘[JM]%’<br>前缀字符^（脱字号）来否定<br>WHERE cust_contact LIKE ‘[^JM]%’ –WHERE NOT cust_contact LIKE ‘[JM]%’</p>
<h2 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h2><h3 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h3><p>mysql必须使用函数</p>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>别名（alias）是一个字段或值的替换名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(vend_name, &#39; (&#39;, vend_country, &#39;)&#39;)</span><br><span class="line">AS vend_title</span><br><span class="line">FROM Vendors</span><br><span class="line">ORDER BY vend_name;</span><br></pre></td></tr></table></figure>
<p>expanded_price列输出quantity*item_price的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_id,</span><br><span class="line">quantity,</span><br><span class="line">item_price,</span><br><span class="line">quantity*item_price AS expanded_price</span><br><span class="line">FROM OrderItems</span><br><span class="line">WHERE order_num &#x3D; 20008;</span><br></pre></td></tr></table></figure>
<p>SELECT语句为测试、检验函数和计算提供了很好的用法。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>RTRIM()去掉字符串尾的空格的。不同DBMS使用函数不同。</p>
<h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><p>聚集函数（aggregate function） 对某些行运行的函数，计算并返回一个值.<br>AVG() 返回某列的平均值<br>COUNT() 返回某列的行数<br>MAX() 返回某列的最大值<br>MIN() 返回某列的最小值<br>SUM() 返回某列值之和<br>使用对所有行执行计算，指定ALL参数或不指定参数（默认是ALL）。<br>只包含不同的值，指定DISTINCT参数，DISTINCT不能用于COUNT(*)必须指定列。</p>
<p>AVG() 返回某列的平均值，只用于单个列，多个列用过个函数，忽略包含NULL值的行。<br><code>SELECT AVG(prod_price) AS avg_price FROM Products;</code><br>COUNT()函数有两种使用方式：<br>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。<br>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</p>
<p>MAX()返回指定列中的最大值，忽略NULL行。 汉字根据字符集大小决定，如utf-8齐大于刘，王。<br>MIN()的功能正好与MAX()功能相反<br>SUM()函数用来返回指定列值的和（总计），忽略NULL行<br>SELECT SUM(quantity) AS items_ordered<br>SELECT SUM(item_price*quantity) AS total_price </p>
<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p>使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM Products</span><br><span class="line">GROUP BY vend_id;--GROUP BY语句指示DBMS按vend_id排序并分组数据。</span><br></pre></td></tr></table></figure>

<p>使用GROUP BY语句重要的规定<br>GROUP BY子句可以包含任意数目的列，并对分组进行嵌套，进一步进行分组<br>嵌套分组数据将在最后指定的分组上嵌套<br>GROUP BY子句列出的不许是检索列或者表达式（不能是聚集函数）,GROUP BY子句中表达式与SELECT相同，不能用别名。<br>一般不允许GROUP BY拥有长度可变的数据类型<br>除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出。<br>NULL值作为一个分组返回<br>GROUP BY位于WHERE之后，ORDER BY之前。</p>
<p>通过相对位置指定列<br>GROUP BY 2, 1可表示按选择的第2个列分组，然后再按第1个列分组。</p>
<h2 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h2><p>HAVING支持所有WHERE操作符</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id, COUNT(*) AS orders</span><br><span class="line">FROM Orders</span><br><span class="line">GROUP BY cust_id</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 2;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prods</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_price &gt;&#x3D; 4 --价格大于4</span><br><span class="line">GROUP BY vend_id</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 2;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_num, COUNT(*) AS items</span><br><span class="line">FROM OrderItems</span><br><span class="line">GROUP BY order_num</span><br><span class="line">HAVING COUNT(*) &gt;&#x3D; 3</span><br><span class="line">ORDER BY items, order_num; --一般在使用GROUP BY子句时，应该也给出ORDER BY子句，保证数据正确排序。</span><br></pre></td></tr></table></figure>

<h3 id="SELECT子句顺序"><a href="#SELECT子句顺序" class="headerlink" title="SELECT子句顺序"></a>SELECT子句顺序</h3><p>SELECT     要返回的列或表达式  必须使用<br>FROM       从中检索数据的表    仅在从表选择数据时使用<br>WHERE      行级过滤           非必须使用<br>GROUP BY   分组说明           仅在按组计算聚集时使用<br>HAVING     组级过滤           非必须使用<br>ORDER BY   输出排序顺序       非必须使用</p>
<h2 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h2><p>子查询即嵌套在其他查询中的查询。SELECT是简单查询， 从单个数据库表中检索数据的单条语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_id</span><br><span class="line">FROM Orders</span><br><span class="line">WHERE order_num IN (SELECT order_num</span><br><span class="line">FROM OrderItems                      --可多层嵌套，实际考虑性能。</span><br><span class="line">WHERE prod_id &#x3D; &#39;RGAN01&#39;);</span><br></pre></td></tr></table></figure>
<p>上述分为两个步骤：<br>SELECT order_num FROM orderitems WHERE prod_id=’RGAN01’<br>SELECT cust_id FROM orders WHERE order_num IN (20007,20008)</p>
<p>作为子查询的SELECT语句只能查询单个列作为子查询的SELECT语句只能查询单个列。</p>
<h2 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h2><p>显示Customers表中每个顾客的订单总数，订单与相应的顾客ID存储在Orders表中。</p>
<ol>
<li>从Customers表中检索顾客列表；</li>
<li>对于检索出的每个顾客，统计其在Orders表中的订单数量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name,</span><br><span class="line">cust_state,</span><br><span class="line">(SELECT COUNT(*)</span><br><span class="line">FROM Orders</span><br><span class="line">WHERE Orders.cust_id &#x3D; Customers.cust_id) AS orders</span><br><span class="line">FROM Customers</span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure>
完全限定列名 表名.列名 </li>
</ol>
<h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><p>联结 执行中联结（join）表</p>
<h3 id="关系表"><a href="#关系表" class="headerlink" title="关系表"></a>关系表</h3><p>关系数据库就是要把信息分解成多个表，一类数据一个表，各表通过某些共同的值作为主键（primary key）互相关联。<br>关系数据库的可伸缩性远远比关系数据库要好，可伸缩性指的是能够适应不断增加的工作量而不失败。</p>
<p>用一条SELECT语句就检索出存储在多个表的数据。 </p>
<h3 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h3><p>等值联结（equijoin）也叫内联结（inner join）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM Vendors, Products</span><br><span class="line">WHERE Vendors.vend_id &#x3D; Products.vend_id;--使用WHERE语句进行联结。</span><br></pre></td></tr></table></figure>
<p>没有WHERE子句，第一个表中的每一行将与第二个表中的每一行配对。<br>笛卡儿积（cartesian product）由没有联结条件的表关系返回的结果,有时也叫叉联结（cross join），检索出的行的数<br>目将是第一个表中的行数乘以第二个表中的行数。</p>
<h3 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h3><p>内联结出了用WHERE以外，ANSI SQL规范首选INNER JOIN语法。参阅DBMS文档。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM Vendors INNER JOIN Products</span><br><span class="line">ON Vendors.vend_id &#x3D; Products.vend_id;--ON 替代WHERE</span><br></pre></td></tr></table></figure>
<h4 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h4><p>SELECT语句返回订购产品RGAN01的顾客列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM Customers, Orders, OrderItems</span><br><span class="line">WHERE Customers.cust_id &#x3D; Orders.cust_id</span><br><span class="line">AND OrderItems.order_num &#x3D; Orders.order_num</span><br><span class="line">AND prod_id &#x3D; &#39;RGAN01&#39;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">FROM Orders</span><br><span class="line">WHERE order_num IN (SELECT order_num--用嵌套实现</span><br><span class="line">FROM OrderItems</span><br><span class="line">WHERE prod_id &#x3D; &#39;RGAN01&#39;));</span><br></pre></td></tr></table></figure>
<h3 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h3><h4 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h4><p>缩短SQL语句；<br>允许在一条SELECT语句中多次使用相同的表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM Customers AS C, Orders AS O, OrderItems AS OI</span><br><span class="line">WHERE C.cust_id &#x3D; O.cust_id</span><br><span class="line">AND OI.order_num &#x3D; O.order_num</span><br><span class="line">AND prod_id &#x3D; &#39;RGAN01&#39;;</span><br></pre></td></tr></table></figure>
<p>表别名只在查询执行中使用。与列别名不一样，表别名不返回到客户端</p>
<p>内联结，自联结（self-join）、自然联结（natural join）和外<br>联结（outer join）</p>
<h4 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h4><p>给与Jim Jones同一公司的所有顾客发送一封信件<br>首先找出Jim Jones工作的公司，然后找出在该公司用作的顾客</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#方法一</span><br><span class="line">SELECT cust_id, cust_name, cust_contact</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_name &#x3D; (SELECT cust_name</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_contact &#x3D; &#39;Jim Jones&#39;);</span><br><span class="line">#方法二 自联结一般比子查询快</span><br><span class="line">SELECT c1.cust_id, c1.cust_name, c1.cust_contact</span><br><span class="line">FROM Customers AS c1, Customers AS c2</span><br><span class="line">WHERE c1.cust_name &#x3D; c2.cust_name</span><br><span class="line">AND c2.cust_contact &#x3D; &#39;Jim Jones&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="外联结"><a href="#外联结" class="headerlink" title="外联结"></a>外联结</h4><p>二种基本的外联结形式：左外联结和右外联结，–全外联结（full outer join）mysql不支持。<br>外联结：包含了那些在相关表中没有关联行的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT Customers.cust_id, Orders.order_num</span><br><span class="line">FROM Customers LEFT OUTER JOIN Orders --OUTER JOIN来指定联结类型</span><br><span class="line">ON Customers.cust_id &#x3D; Orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表。</p>
<h3 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h3><p>检索所有顾客及每个顾客所下的订单数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#内联结</span><br><span class="line">SELECT Customers.cust_id,</span><br><span class="line">COUNT(Orders.order_num) AS num_ord</span><br><span class="line">FROM Customers INNER JOIN Orders</span><br><span class="line">ON Customers.cust_id &#x3D; Orders.cust_id</span><br><span class="line">GROUP BY Customers.cust_id;</span><br><span class="line"></span><br><span class="line">#外联结 外联结可以打印出所有客户，包括没订单的</span><br><span class="line">SELECT Customers.cust_id,</span><br><span class="line">COUNT(Orders.order_num) AS num_ord</span><br><span class="line">FROM Customers LEFT OUTER JOIN Orders</span><br><span class="line">ON Customers.cust_id &#x3D; Orders.cust_id</span><br><span class="line">GROUP BY Customers.cust_id;</span><br></pre></td></tr></table></figure>
<h3 id="使用联结和联结条件"><a href="#使用联结和联结条件" class="headerlink" title="使用联结和联结条件"></a>使用联结和联结条件</h3><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>利用UNION操作符将多条SELECT语句组合成一个结果集<br>并（union）或复合查询（compound query）<br>1.在一个查询中从不同的表返回结构数据；<br>2.对一个表执行多个查询，按一个查询返回数据。<br>需要Illinois、Indiana和Michigan等美国各个州的所有顾客的报表，还想包括不管位于哪个州的所有的Fun4All</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_state IN (&#39;IL&#39;,&#39;IN&#39;,&#39;MI&#39;)</span><br><span class="line">UNION</span><br><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_name &#x3D; &#39;Fun4All&#39;;</span><br><span class="line">#</span><br><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_state IN (&#39;IL&#39;,&#39;IN&#39;,&#39;MI&#39;)</span><br><span class="line">OR cust_name &#x3D; &#39;Fun4All&#39;;</span><br></pre></td></tr></table></figure>
<h3 id="UNION规则"><a href="#UNION规则" class="headerlink" title="UNION规则"></a>UNION规则</h3><p>1.UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔。<br>2.UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。<br>3.列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。</p>
<h4 id="包含或取消重复的行"><a href="#包含或取消重复的行" class="headerlink" title="包含或取消重复的行"></a>包含或取消重复的行</h4><p>UNION总是完成与多个WHERE条件相同的操作，如果需要每个匹配行都出现，必须使用UNION ALL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_state IN (&#39;IL&#39;,&#39;IN&#39;,&#39;MI&#39;)</span><br><span class="line">UNION ALL  --UNION ALL返回所有值，UNION返回不重复的值</span><br><span class="line">SELECT cust_name, cust_contact, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_name &#x3D; &#39;Fun4All&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="对组合查询结果排序"><a href="#对组合查询结果排序" class="headerlink" title="对组合查询结果排序"></a>对组合查询结果排序</h4><p>用UNION组合查询时，只能使用一条ORDER BY子句，它必须位于最后一条SELECT语句之后.<br>另外两种UNION：EXCEPT（有时称为MINUS）可用来检索只在第一个表中存在而在第二个表中不存在的行；<br>INTERSECT可用来检索两个表中都存在的行。<br>UNION与别名组合，检索一个结果集，操作多个表。</p>
<h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>INSERT用来将行插入（或添加）到数据库表。<br>插入完整的行；<br>插入行的一部分；<br>插入某些查询的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO Customers-- INTO 可选</span><br><span class="line">VALUES(&#39;1000000006&#39;,&#39;Toy Land&#39;,&#39;123 Any Street&#39;,</span><br><span class="line">&#39;New York&#39;,&#39;NY&#39;,&#39;11111&#39;,&#39;USA&#39;,NULL,NULL);</span><br><span class="line">#推荐明确给出列名，这种方法还可以省略列。</span><br><span class="line">INSERT INTO Customers(cust_id,</span><br><span class="line">cust_name,cust_address,cust_city,cust_state,cust_zip,</span><br><span class="line">cust_country,cust_contact,cust_email)</span><br><span class="line">VALUES(&#39;1000000006&#39;,&#39;Toy Land&#39;,&#39;123 Any Street&#39;,&#39;New York&#39;,</span><br><span class="line">&#39;NY&#39;,&#39;11111&#39;,&#39;USA&#39;,NULL,NULL);</span><br></pre></td></tr></table></figure>
<p>省略的列必须满足以下某个条件。<br>该列定义为允许NULL值（无值或空值）。<br>在表定义中给出默认值。这表⽰如果不给出值，将使用默认值。</p>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><p>从名为CustNew的表中读出数据并插入到Customers表<br>在填充CustNew时，不应该使用已经在Customers中用过的cust_id值（如果主键值重复，后续的INSERT操作将会失败）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSERT INTO Customers(cust_id,</span><br><span class="line">cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,</span><br><span class="line">cust_zip,cust_country)</span><br><span class="line">SELECT cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,</span><br><span class="line">cust_state,cust_zip,cust_country FROM CustNew;</span><br></pre></td></tr></table></figure>
<p>INSERT SELECT中SELECT语句可以包含WHERE子句，以过滤插图的数据。<br>INSERT通常只插入一条，INSERT SELECT是个例外，它可以用一条INSERT插入多行。</p>
<h3 id="从一个表复制到另一个表"><a href="#从一个表复制到另一个表" class="headerlink" title="从一个表复制到另一个表"></a>从一个表复制到另一个表</h3><p>SELECT INTO将数据复制到一个新表<br>INSERT SELECT与SELECT INTO区别：前者导出数据，而后者导入数据.<br>创建一个名为CustCopy的新表，并把Customers表的整个内容复制到新表中。<br><code>SELECT * INTO CustCopy FROM Customers;</code><br><code>CREATE TABLE CustCopy AS SELECT * FROM Customers;</code></p>
<p>任何SELECT选项和子句都可以使用，包括WHERE和GROUP BY；<br>可利用联结从多个表插入数据；<br>不管从多少个表中检索数据，数据都只能插入到一个表中。</p>
<h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>有两种使用UPDATE的方式：更新表中的特定行；更新表中的所有行。<br>基本的UPDATE语句<br>要更新的表；列名和它们的新值；确定要更新哪些行的过滤条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE Customers</span><br><span class="line">SET cust_contact &#x3D; &#39;Sam Roberts&#39;,</span><br><span class="line">cust_email &#x3D; &#39;sam@toyland.com&#39;</span><br><span class="line">WHERE cust_id &#x3D; &#39;1000000006&#39;; --没有这句，DBMS将用这个电子邮件地址更新Customers表中的所有行</span><br></pre></td></tr></table></figure>
<p>UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据</p>
<p>要删除某个列的值，可设置它为NULL（假如表定义允许NULL值），区别’’，后者是个值。<br>UPDATE Customers<br>SET cust_email = NULL<br>WHERE cust_id = ‘1000000005’;</p>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>有两种使用DELETE的方式：<br>从表中删除特定的行；<br>从表中删除所有行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM Customers</span><br><span class="line">WHERE cust_id &#x3D; &#39;1000000006&#39;;</span><br></pre></td></tr></table></figure>

<p>DELETE不需要列名或通配符。DELETE删除整行而不是删除列。要删除指定的列，请使用UPDATE语句。<br>DELETE删除表的内容而不是表。<br>TRUNCATE TABLE语句不记录数据变动，删除所有行更快。</p>
<h3 id="更新和删除的指导原则"><a href="#更新和删除的指导原则" class="headerlink" title="更新和删除的指导原则"></a>更新和删除的指导原则</h3><ol>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。</li>
<li>保证每个表都有主键，尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。</li>
<li>在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进⾏测试，保证它过滤的是正确的记录，<br>以防编写的WHERE⼦句不正确。</li>
<li>使用强制实施引用完整性的数据库，这样DBMS将不允许删除其数据与其他表相关联的行。</li>
<li>有的DBMS允许数据库管理员施加约束，防止执行不带WHERE子句的UPDATE或DELETE语句。如果所采用的DBMS支持这个特性，应该使用它。<h2 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3>CREATE TABLE创建表<br>新表的名字，在关键字CREATE TABLE之后给出；<br>表列的名字和定义，用逗号分隔；<br>有的DBMS还要求指定表的位置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Products</span><br><span class="line">(</span><br><span class="line">prod_id CHAR(10) NOT NULL, --NOT NULL 插入没有值的列时会报错。</span><br><span class="line">vend_id CHAR(10) NOT NULL,</span><br><span class="line">prod_name CHAR(254) NOT NULL,</span><br><span class="line">prod_price DECIMAL(8,2) NOT NULL,</span><br><span class="line">prod_desc VARCHAR(1000) --不指定NULL，默认为NULL。</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
只有不允许NULL值的列可作为主键，允许NULL值的列不能作为唯一标识<br>默认值在CREATE TABLE语句的列定义中用关键字DEFAULT指定<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE OrderItems</span><br><span class="line">(</span><br><span class="line">order_num INTEGER NOT NULL,</span><br><span class="line">order_item INTEGER NOT NULL,</span><br><span class="line">prod_id CHAR(10) NOT NULL,</span><br><span class="line">quantity INTEGER NOT NULL DEFAULT 1,</span><br><span class="line">item_price DECIMAL(8,2) NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
MySQL用户指定DEFAULT CURRENT_DATE()；<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3>理想情况下，不要在表中包含数据时对其进行更新。应该在表的设计过程中充分考虑未来可能的需求，避免今后对表的结构做大改动。<br>所有的DBMS都允许给现有的表增加列，不过对所增加列的数据类型（以及NULL和DEFAULT的使用）有所限制。<br>许多DBMS不允许删除或更改表中的列。<br>多数DBMS允许重新命名表中的列。<br>许多DBMS限制对已经填有数据的列进行更改，对未填有数据的列几乎没有限制。<br>使用ALTER TABLE更改表结构</li>
<li>在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）；</li>
<li>列出要做哪些更改。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE Vendors ADD vend_phone CHAR(20);</span><br><span class="line">ALTER TABLE Vendors DROP COLUMN vend_phone;</span><br></pre></td></tr></table></figure>
使用ALTER TABLE要极为⼩⼼，应该在进行改动前做完整的备份（模式和数据的备份）<br>数据库表的更改不能撤销，如果增加了不需要的列，也许无法删除它们</li>
</ol>
<p>复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：</p>
<ol>
<li>用新的列布局创建一个新表；</li>
<li>使用INSERT SELECT语句（关于这条语句的详细介绍，请参阅<br>第15课）从旧表复制数据到新表。有必要的话，可以使用转换函数和计算字段；</li>
<li>检验包含所需数据的新表；</li>
<li>重命名旧表（如果确定，可以删除它）；</li>
<li>用旧表原来的名字重命名新表；</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键。</li>
</ol>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>DROP TABLE语句<br>DROP TABLE CustCopy; –删除表没有确认，也不能撤销，执行这条语句将永久删除该表</p>
<h4 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h4><p>MySQL使用RENAME</p>
<h2 id="视图（虚拟的表）"><a href="#视图（虚拟的表）" class="headerlink" title="视图（虚拟的表）"></a>视图（虚拟的表）</h2><p>CREATE VIEW只能用于创建不存在的视图<br>DROP VIEW viewname;</p>
<p>利用视图简化复杂的联结</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW ProductCustomers AS</span><br><span class="line">SELECT cust_name, cust_contact, prod_id</span><br><span class="line">FROM Customers, Orders, OrderItems</span><br><span class="line">WHERE Customers.cust_id &#x3D; Orders.cust_id</span><br><span class="line">AND OrderItems.order_num &#x3D; Orders.order_num;</span><br><span class="line"></span><br><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM ProductCustomers</span><br><span class="line">WHERE prod_id &#x3D; &#39;RGAN01&#39;;</span><br><span class="line">#用视图重新格式化检索出的数据</span><br><span class="line"></span><br><span class="line">CREATE VIEW VendorLocations AS</span><br><span class="line">SELECT RTRIM(vend_name) + &#39; (&#39; + RTRIM(vend_country) + &#39;)&#39;--mysql拼接必须使用函数</span><br><span class="line">AS vend_title</span><br><span class="line">FROM Vendors;</span><br><span class="line">SELECT * FROM VendorLocations;</span><br><span class="line"></span><br><span class="line">#用视图过滤不想要的数据</span><br><span class="line">CREATE VIEW CustomerEMailList AS</span><br><span class="line">SELECT cust_id, cust_name, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_email IS NOT NULL; --过滤没有邮件的客户</span><br><span class="line"></span><br><span class="line">SELECT * FROM CustomerEMailList;</span><br><span class="line">#使用视图与计算字段</span><br><span class="line">CREATE VIEW OrderItemsExpanded AS</span><br><span class="line">SELECT order_num,</span><br><span class="line">prod_id,</span><br><span class="line">quantity,</span><br><span class="line">item_price,</span><br><span class="line">quantity*item_price AS expanded_price</span><br><span class="line">FROM OrderItems；</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM OrderItemsExpanded</span><br><span class="line">WHERE order_num &#x3D; 20008;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><p>使用事务处理（transaction processing），通过确保成批的SQL操作要么完全执行，要么完全不执行，来维护数据库的完整性。<br>事务处理需要知道的几个术语<br>事务（transaction）指一组SQL语句；<br>回退（rollback）指撤销指定SQL语句的过程；<br>提交（commit）指将未存储的SQL语句结果写⼊数据库表；<br>保留点（savepoint）指事务处理中设置的临时占位符<br>（placeholder），可以对它发布回退（与回退整个事务处理不同）。<br>事务处理用来管理INSERT、UPDATE和DELETE语句<br>不能回退SELECT语句，CREATE或DROP操作。事务处理中可以使用这些语句，但进行回退<br>时，这些操作也不撤销。</p>
<h3 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h3><p>一般的SQL语句都是针对数据库表直接执行和编写的。这就是所谓的<br>隐式提交（implicit commit），即提交（写或保存）操作是自动进行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#MySQL</span><br><span class="line">START TRANSACTION</span><br><span class="line">...</span><br><span class="line">DELETE FROM Orders;</span><br><span class="line">ROLLBACK;   --回退（撤销）</span><br><span class="line"></span><br><span class="line">SET TRANSACTION</span><br><span class="line">DELETE OrderItems WHERE order_num &#x3D; 12345;</span><br><span class="line">DELETE Orders WHERE order_num &#x3D; 12345;</span><br><span class="line">COMMIT;--mysql一般默认开启aotucommit，使用show variables like &#39;%autocommit%&#39;查看</span><br><span class="line">#保留点</span><br><span class="line">SAVEPOINT delete1;-- 支持回退部分事务，回退到占位符即保留点。</span><br></pre></td></tr></table></figure>
<h3 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h3><h3 id="高级SQL特性"><a href="#高级SQL特性" class="headerlink" title="高级SQL特性"></a>高级SQL特性</h3><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><h4 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h4><p>外键有助防止意外删除<br>级联删除（cascading delete）：从一个表中删除行时删除所有相关的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#使用了REFERENCES关键字，它表示cust_id中的任何值都必须是Customers表的cust_id中的值。</span><br><span class="line">CREATE TABLE Orders</span><br><span class="line">(</span><br><span class="line">order_num INTEGER NOT NULL PRIMARY KEY,</span><br><span class="line">order_date DATETIME NOT NULL,</span><br><span class="line">cust_id CHAR(10) NOT NULL REFERENCES</span><br><span class="line">Customers(cust_id)</span><br><span class="line">);</span><br><span class="line">#在ALTER TABLE语句中用CONSTRAINT语法来完成</span><br><span class="line">ALTER TABLE Orders</span><br><span class="line">ADD CONSTRAINT</span><br><span class="line">FOREIGN KEY (cust_id) REFERENCES Customers (cust_id)</span><br></pre></td></tr></table></figure>
<p>唯一约束既可以用UNIQUE关键字在表定义中定义，也可以用单独的CONSTRAINT定义。<br>与主键的区别：<br>表可包含多个唯一约束，但每个表只允许一个主键。<br>唯一约束列可包含NULL值。<br>唯一约束列可修改或更新。<br>唯一约束列的值可重复使用。<br>与主键不一样，唯一约束不能用来定义外键。</p>
<h3 id="检查约束"><a href="#检查约束" class="headerlink" title="检查约束"></a>检查约束</h3><p>检查约束用来保证一列（或一组列）中的数据满足一组指定的条件。</p>
<p>```<br>CREATE TABLE OrderItems<br>(<br>order_num INTEGER NOT NULL,<br>order_item INTEGER NOT NULL,<br>prod_id CHAR(10) NOT NULL,<br>quantity INTEGER NOT NULL CHECK (quantity &gt; 0),<br>item_price MONEY NOT NULL<br>);</p>
<p>ADD CONSTRAINT CHECK (gender LIKE ‘[MF]’)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/06/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" data-id="ckipfqjc4000edobxcztc1bbn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-linux基本操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/06/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2020-12-06T05:48:40.000Z" itemprop="datePublished">2020-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/06/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">linux基本操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>linux查看软件安装情况<br>查看软件是否安装<br>rpm -qa|grep mysql<br>查看软件包安装的文件<br>rpm -ql mysql-community-libs-5.6.50-2.el7.x86_64<br>查看mysql所有安装包的文件存储位置<br>rpm -qal |grep mysql<br>yum search 查找对应可以安装的软件包<br>find / -name mysql 有包含mysql服务的文件路径<br>Which查找命令which mysql<br>Whereis命令whereis mysql  find类似</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/06/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" data-id="ckipfqjbm0007dobx60ch5scj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql基本操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/06/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="article-date">
  <time datetime="2020-12-06T02:44:52.000Z" itemprop="datePublished">2020-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/06/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">mysql基本操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>配置mysql开机自启动<br>1.chkconfig –add mysql<br>2.chkconfig mysqld on<br>命令启动/关闭mysql实例<br>1.service mysqld start/stop<br>2./etc/init.d/mysqld start/stop<br>命令关闭MySQL<br>mysqladmin -p -u root shutdown<br>检查mysql是否真正的启动<br>netstat -tulpn | grep 3306<br>查询进程<br>ps -ef | grep mysqld</p>
<p>增删改查<br><a target="_blank" rel="noopener" href="https://my.oschina.net/u/4115134/blog/3189198">https://my.oschina.net/u/4115134/blog/3189198</a></p>
<p>连接mysql服务器<br>mysql -uroot -proot  -u用户名 -proot<br>连接mysql服务器并指定IP和端口<br>mysql -uroot -proot -h127.0.0.1 -P3306 -h IP服务器主机名IP地址  3306位默认端口<br>注释 #、/**/、–添加注释</p>
<p>数据库及表操作<br>1.创建删除查看数据库<br>查看数据库<br><code>show databases;</code><br>进入某数据库进行操作<br><code>use 库名；</code><br>查看已进入的库<br><code>SELECT DATABASE（）；</code><br>查看当前数据库中的所有表<br><code>show tables;</code><br>删除数据库<br><code>drop database mydb1;</code><br><code>drop database if exists mydb1;</code><br>创建mydb1库，指定编码为utf8<br><code>create database mydb1 charset utf8;</code><br><code>create database if not exists mydb1 charset utf8;</code><br>查看建库时的语句（并验证数据库库使用的编码）<br><code>show create database mydb1;</code><br>2.创建、删除、查看表<br>进入mydb1库，删除stu学生表(如果原本存在)<br><code>use mydb1;</code><br><code>drop table if exists stu;</code><br>创建stu学生表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">use mydb1;</span><br><span class="line">drop table if exists stu;</span><br><span class="line">create table stu(</span><br><span class="line">    id int primary key auto_increment,  -- 设置id为主键</span><br><span class="line">    name varchar(50),</span><br><span class="line">    gender varchar(10),</span><br><span class="line">    birthday date,</span><br><span class="line">    score double</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>查看STU学生表结构<br>desc stu；</p>
<h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>– 10.往学生表(stu)中插入记录(数据)<br>– 语法：INSERT INTO 表名(列名1,列名2,列名3…) VALUES(值1,值2,值3…);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into stu(id,name,gender,birthday,score) value ( null,&#39;王二妮&#39;,&#39;女&#39;,&#39;2001-3-4&#39;,89);</span><br><span class="line">insert into stu values(null,&#39;李铁柱&#39;,&#39;男&#39;,&#39;1998-1-1&#39;, 84);</span><br><span class="line">insert into stu values(null,&#39;陈翠花&#39;,&#39;女&#39;,&#39;2000-2-5&#39;, 90);</span><br><span class="line">insert into stu(name,gender) values(&#39;张三&#39;,&#39;男&#39;);</span><br></pre></td></tr></table></figure>
<h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><p>drop、delete、truncate三者的区别.<br>(1)drop是用于删除库和表，delete和truncate是用于删除表记录<br>(2)delete是删除表中的记录,可以删除部分记录,也可以删除所有记录, 对表本身没有影响<br>(3)truncate是只能删除表中的所有记录, 不能删除部分记录, 并且truncate删除是将表摧毁再重建, 对表有影响(比如,会将自增变量的值重置为1)</p>
<p>– 14.删除stu表中所有的记录<br>– 删除记录语法: DELETE FROM 表名 [where条件]<br>delete from stu;<br>truncate table stu;</p>
<p>– 仅删除符合条件的<br>delete from stu where id&gt;3;</p>
<h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p>– 12.修改stu表中所有学生的成绩，加10分特长分<br>– 修改语法: UPDATE 表名 SET 列=值,列=值,列=值…[WHERE子句];<br><code>update stu set score=score+10;</code><br>– 13.修改stu表中编号为1的学生成绩，将成绩改为83分。<br><code>update stu set score=83 where id=1;</code></p>
<h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><p>– 11.查询stu表所有学生的信息<br>– 语法：SELECT 列名 | * FROM 表名<br><code>select * from stu;</code><br>–15.查询emp表中的所有员工，显示姓名，薪资，奖金<br><code>select name, sal, bonus from emp;</code><br>– 16.查询emp表中的所有部门和职位<br><code>select dept, job from emp;</code><br>– 在select之后、列名之前，使用DISTINCT 剔除重复的记录<br><code>select distinct dept, job from emp;</code><br>– 17.查询emp表中薪资大于3000的所有员工，显示员工姓名、薪资</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name, sal from emp</span><br><span class="line">where sal&gt;3000;</span><br></pre></td></tr></table></figure>
<p>– 18.查询emp表中总薪资(薪资+奖金)大于3500的所有员工，显示员工姓名、总薪资</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name, sal+bonus from emp</span><br><span class="line">where sal+bonus &gt; 6500; -- 结果不准确</span><br></pre></td></tr></table></figure>
<p>– ifnull(列, 值)函数: 判断指定的列是否包含null值，如果有null值，用第二个值替换null值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name, sal+ifnull(bonus, 0) from emp</span><br><span class="line">where sal+ifnull(bonus, 0) &gt; 6500;</span><br></pre></td></tr></table></figure>

<p>– 注意查看上面查询结果中的表头，如何将表头中的 sal+bonus 修改为 “总薪资”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name as 姓名, sal+ifnull(bonus, 0) as 总薪资 from emp</span><br><span class="line">where sal+ifnull(bonus, 0) &gt; 6500;</span><br></pre></td></tr></table></figure>
<p>– as用于指定别名, as可以省略。<br>– where子句中不能使用列别名<br>– 19.查询emp表中薪资在3000和4500之间的员工，显示员工姓名和薪资</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select name, sal from emp</span><br><span class="line">where sal&gt;&#x3D;3000 and sal&lt;&#x3D;4500;</span><br><span class="line">-- 提示: between...and... 在..和..之间</span><br><span class="line">select name, sal from emp</span><br><span class="line">where sal between 3000 and 4500; -- 默认包含头和尾</span><br></pre></td></tr></table></figure>
<p>– 20.查询emp表中薪资为 5600、3000、4200的员工，显示员工姓名和薪资</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select name, sal from emp</span><br><span class="line">where sal&#x3D;5600 or sal&#x3D;3000 or sal&#x3D;4200;</span><br><span class="line">-- 或</span><br><span class="line">select name, sal from emp</span><br><span class="line">where sal in(5600,3000,4200);</span><br></pre></td></tr></table></figure>

<p>– 21.查询薪资不为5600、3000、4200的员工</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select name, sal from emp</span><br><span class="line">where sal!&#x3D;5600 and sal!&#x3D;3000 and sal!&#x3D;4200;</span><br><span class="line">-- 或</span><br><span class="line">select name, sal from emp</span><br><span class="line">where not(sal&#x3D;5600 or sal&#x3D;3000 or sal&#x3D;4200);</span><br><span class="line">-- 或</span><br><span class="line">select name, sal from emp</span><br><span class="line">where sal not in(5600,3000,4200);</span><br></pre></td></tr></table></figure>
<p>– 22.查询emp表中薪资大于8000和薪资小于4000的员工，显示员工姓名、薪资。(自己完成)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name,sal from emp</span><br><span class="line">where sal&gt;&#x3D;8000 or sal&lt;&#x3D;4000;</span><br></pre></td></tr></table></figure>
<p>– 23.查询emp表中薪资大于3000并且奖金小于600的员工，显示员工姓名、薪资、奖金。(自己完成)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name,sal,bonus from emp</span><br><span class="line">where sal&gt;6000 and bonus&lt;1000;</span><br></pre></td></tr></table></figure>
<p>– 处理null值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select name,sal,bonus from emp</span><br><span class="line">where sal&gt;6000 and ifnull(bonus,0)&lt;1000;</span><br></pre></td></tr></table></figure>
<p>– 24.查询没有部门的员工（即部门列为null值）<br>select * from emp<br>where dept is null;</p>
<p>– 思考：如何查询有部门的员工（即部门列不为null值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from emp</span><br><span class="line">where dept is not null; --正确</span><br><span class="line"></span><br><span class="line">select * from emp</span><br><span class="line">where dept not is null; -- 错误!</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/06/mysql%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" data-id="ckipfqjbj0006dobxf01hgcxf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-mysql安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/06/mysql%E5%AE%89%E8%A3%85/" class="article-date">
  <time datetime="2020-12-06T02:35:25.000Z" itemprop="datePublished">2020-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/06/mysql%E5%AE%89%E8%A3%85/">mysql安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/06/mysql%E5%AE%89%E8%A3%85/" data-id="ckipfqjbo0008dobxggxt97rk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络拓扑结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/05/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-12-05T13:48:46.000Z" itemprop="datePublished">2020-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/05/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/">网络拓扑结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>网络的拓扑结构就是网络的各结点的连接形状和方法。</p>
<h1 id="网络拓扑分类："><a href="#网络拓扑分类：" class="headerlink" title="网络拓扑分类："></a>网络拓扑分类：</h1><h2 id="1-总线拓扑"><a href="#1-总线拓扑" class="headerlink" title="1.总线拓扑"></a>1.总线拓扑</h2><p>总线型拓扑采用单根传输线作为传输介质（一般为同轴电缆），所有站点共享一条传输信道，一次只能由一个设备传输信号，目的站点匹配分组目的地址，复制内容。<br>优点：1.各站点互不影响。2.安装维护方便，电缆节约<br>结构简单。3.可靠性高，无源工作。<br>缺点：系统范围受到限制，需要中继器扩展，故障诊断困难，需要诊断各节点。故障隔离困难，总线故障，网络瘫痪。</p>
<h2 id="2-星型拓扑"><a href="#2-星型拓扑" class="headerlink" title="2.星型拓扑"></a>2.星型拓扑</h2><p>各结点通过单独线路连接中央节点，相互独立。中心节点一般为交换机。典型实例：专用交换机（private branch exchange，PBX）。<br>优点：控制简单,服务部署方便。容易实现故障诊断和隔离。系统扩展容易。低延迟。<br>缺点：耗费电缆，安装维护成本高，中心节点容易出现瓶颈，故障则网络瘫痪，各站点分部处理能力低。</p>
<h2 id="3-环形拓扑"><a href="#3-环形拓扑" class="headerlink" title="3.环形拓扑"></a>3.环形拓扑</h2><p>网络各节点通过一条通信线路连接，且数据以分组形式沿一定方向传输，形成闭环。 可以是单向或者双向。各站点有控制收发的访问逻辑。<br>优点：1.电缆长度短，类似总线型。2.扩展容易。3.单向传输，适合光纤，且路由控制简单。4.抗故障性能好。<br>缺点：1.单结点故障影响整个网络。2.检测故障困难。3.使用令牌传递方式，负载轻的时候，延迟高。</p>
<h2 id="4-树形拓扑"><a href="#4-树形拓扑" class="headerlink" title="4.树形拓扑"></a>4.树形拓扑</h2><p>树形拓扑是分层结构，根接收信号，广播发送全网。<br>优点组网灵活，易于扩展，线路长度比星型短 故障隔离容易，隔离分支或节点。缺点：对根要求较高</p>
<h2 id="5-网状拓扑"><a href="#5-网状拓扑" class="headerlink" title="5.网状拓扑"></a>5.网状拓扑</h2><p>优点：不受瓶颈问题和失效问题的影响。可靠性高。<br>缺点：结构复杂，成本比较高；网状拓扑结构的网络协议比较复杂。</p>
<h2 id="6-混合型拓扑"><a href="#6-混合型拓扑" class="headerlink" title="6.混合型拓扑"></a>6.混合型拓扑</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/05/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84/" data-id="ckipfqjc1000ddobx9v4e9iwn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-github-CND建设" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/02/github-CND%E5%BB%BA%E8%AE%BE/" class="article-date">
  <time datetime="2020-12-02T03:49:10.000Z" itemprop="datePublished">2020-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/02/github-CND%E5%BB%BA%E8%AE%BE/">github_CND建设</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>jsDeliver-Github-搭建<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/cungudafa/article/details/104274949">https://blog.csdn.net/cungudafa/article/details/104274949</a></p>
<p>大佬地址：<a target="_blank" rel="noopener" href="https://www.sakura521.cn/">https://www.sakura521.cn/</a><br>git fetch  –recurse-submodules <a target="_blank" rel="noopener" href="https://github.com/iissnan/hexo-theme-next.git">https://github.com/iissnan/hexo-theme-next.git</a> themes/next</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/02/github-CND%E5%BB%BA%E8%AE%BE/" data-id="ckipfqjbf0004dobxgiat0kno" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/12/15/HCIA/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/12/14/%E5%9B%BE%E5%BA%8A%E6%90%AD%E5%BB%BA/">图床搭建</a>
          </li>
        
          <li>
            <a href="/2020/12/14/MarkDown%E8%AF%AD%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/12/13/%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">博客常见问题</a>
          </li>
        
          <li>
            <a href="/2020/12/06/mysql%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/">mysql必知必会</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>